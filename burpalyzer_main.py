#!/usr/bin/env python3
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
import calendar
import os
import sys
from collections import defaultdict
from pprint import pformat

from burpalyzer_constants import *
from burpalyzer_debugging import debug
from chat_parser import read_folder_as_simple_group, simple_group_to_burp_data, read_fixup_list, group_by_month_and_year
from file_tools import write_html
from html_tools import html_framework, htlm_add_burp_list, htm_add_footer


# TODO:
# * Document the "raw", "simple_group" and "burp_data" formats.
# * Add support for the multiburp feature available since chatbot 1.2.0.0
# * Read "simple" format logs instead of raw logs to save space.
# * Refactor this into at least ChatParser and BurpAlyzer classes
# * Find a way to automatically clip burps. :D
# * Add DOCTYPE etc. to the HTML

def sort_by_rating(burp_data):
    return sorted(burp_data, key=lambda x: x[KEY_RATING], reverse=True)


# TODO: Try to detect VODs with only a small gap in time between them as the same stream.
def burps_per_stream(burp_data):
    # There has to be a more pythonic way to do this. :D
    vod_to_count = defaultdict(int)
    vod_to_start_time = {}
    for burp in burp_data:
        vod = burp[KEY_VOD]
        burp_start_time = burp[KEY_TIME]
        vod_to_count[vod] += 1
        if vod not in vod_to_start_time or vod_to_start_time[vod] > burp_start_time:
            vod_to_start_time[vod] = burp_start_time
    debug("vod_to_count: " + pformat(vod_to_count))
    debug("vod_to_start_time" + pformat(vod_to_start_time))
    # FIXME: Now turn this into table data :D
    sorted_x = sorted(vod_to_count.items(), key=lambda kv: kv[1], reverse=True)
    debug(pformat(sorted_x))
    debug(len(sorted_x))
    return


# -------------------------------------------------------------------------------------------


def main():
    if len(sys.argv) != 5:
        raise ValueError("Invalid number of arguments")
    botname = sys.argv[1]
    indir = sys.argv[2]
    excludefile = sys.argv[3]
    outdir = sys.argv[4]

    (root, body) = html_framework()

    # Parsing and analysis
    simple_group = read_folder_as_simple_group(indir)
    fixup_list = read_fixup_list(excludefile)
    unsorted_burp_data = simple_group_to_burp_data(simple_group, botname, fixup_list)
    grouped_burps = group_by_month_and_year(unsorted_burp_data)
    monthly_top10s = []
    for month_year, burps_of_month in grouped_burps:
        top10 = sort_by_rating(burps_of_month)[:10]
        title = "Top 10 burps " + calendar.month_name[month_year[0]] + " " + str(month_year[1])
        monthly_top10s.append({"title": title, "data": top10})
        # debug_burp_list(top10)
    for entry in reversed(monthly_top10s):
        htlm_add_burp_list(body, entry["data"], entry["title"], fixup_list)

    # Work-in-progress: Burps per stream
    # burps_per_stream_table = burps_per_stream(burp_data)
    # html_add_table(body, burps_per_stream_table, "Top 10 burps per stream")

    htm_add_footer(body)
    write_html(root, os.path.join(outdir, "index.html"))


if __name__ == "__main__":
    main()
