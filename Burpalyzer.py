#Boost Software License - Version 1.0 - August 17th, 2003
#
#Permission is hereby granted, free of charge, to any person or organization
#obtaining a copy of the software and accompanying documentation covered by
#this license (the "Software") to use, reproduce, display, distribute,
#execute, and transmit the Software, and to prepare derivative works of the
#Software, and to permit third-parties to whom the Software is furnished to
#do so, all subject to the following:
#
#The copyright notices in the Software and this entire statement, including
#the above license grant, this restriction and the following disclaimer,
#must be included in all copies of the Software, in whole or in part, and
#all derivative works of the Software, unless such copies or derivative
#works are solely in the form of machine-executable object code generated by
#a source language processor.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
#SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
#FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
#ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#DEALINGS IN THE SOFTWARE.

import io
import json
import os
import sys
import time
from datetime import datetime
from pprint import pformat
from xml.etree import ElementTree as ET

Burpalyzer_Version = "1.0.0.0"
debug_enabled = True

# TODO:
# * Add support for the multiburp feature available since chatbot 1.2.0.0
# * Read "simple" format logs instead of raw logs to save space.
# * Refactor this into at least ChatParser and BurpAlyzer classes
# * Find a way to automatically clip burps. :D
# * Add DOCTYPE etc. to the HTML

# Shared key names for "simple" and "burp data" formats:
KEY_ID = u"id"
KEY_VOD = u"vod";
KEY_TIME = u"time"
KEY_OFFSET = u"offset"

# Key names for "simple" format only
KEY_USER = u"user"
KEY_TEXT = u"text"

# Key names for "burp data" format only
KEY_RATING = u"rating"

#
# I/O helper functions for reading/writing UTF-8 data
#


def read_json(filename):
    with io.open(filename, 'r', encoding="utf-8") as json_file:
        return json.load(json_file)


def write_json(filename, data):
    with io.open(filename, 'w', encoding="utf-8") as json_file:
        # Work around a bug in json.dump with python 2:
        # https://stackoverflow.com/a/18337754
        # https://bugs.python.org/issue13769
        json_data = json.dumps(data, ensure_ascii=False)
        json_file.write(unicode(json_data))


def write_lines(filename, lines):
    with io.open(filename, 'w', encoding="utf-8") as output_file:
        for line in lines:
            output_file.write(line)
            output_file.write(u"\n")


def write_html(root, filename):
    tree = ET.ElementTree(root)
    with open(filename, 'wb') as html_file:
        tree.write(html_file, encoding='utf-8', xml_declaration=False)


# Reduces "raw" input format of the twitch-chatlog module to what is necessary for analysis.
def raw_to_simple(raw):
    simple = []
    for message in raw:
        s = {
            KEY_VOD: message[u"content_id"],
            KEY_ID: message[u"_id"],
            KEY_TIME: message[u"created_at"],
            KEY_OFFSET: message[u"content_offset_seconds"],
            KEY_USER: message[u"commenter"][u"name"],
            KEY_TEXT: message[u"message"][u"body"]
        }
        simple.append(s)
    return simple


# Reduces the "simple" format to something humans can read in a text editor.
# Not recommend for further processing!
def simple_to_human_readable(simple):
    lines = []
    for message in simple:
        line = u"{time} ({offset}) - {user}: {text}".format(**message)
        lines.append(line)
    return lines


def debug(msg):
    if(debug_enabled):
        print(msg)


def parse_offset(seconds):
    m, s = divmod(int(seconds), 60)
    h, m = divmod(m, 60)
    return h, m ,s


# Formats seconds as HH:MM:SS, e.g. 72.564 => "00:01:12"
def offset_to_hh_mm_ss(seconds):
    h, m, s = parse_offset(seconds)
    return "{:02d}:{:02d}:{:02d}".format(h, m, s)


# Formats seconds in twitch link URL format
def offset_to_twitch_time(seconds):
    h, m, s = parse_offset(seconds)
    return "{:02d}h{:02d}m{:02d}s".format(h, m, s)


# Parses a string like "2021-05-28T21:01:12.495Z" into a datetime object
def parse_chat_timestamp(time_string):
    parsed = datetime.strptime(time_string, "%Y-%m-%dT%H:%M:%S.%fZ") # FIXME: Actually parse the time zone
    return parsed


def datetime_to_human_readable(datetime_object):
    return datetime_object.strftime("%Y-%m-%d %H:%M:%S")

def read_folder_as_simple_group(dirname):
    simple_group = []
    for folder, subfolders, files in os.walk(dirname):
        for file in files:
            filePath = os.path.join(os.path.abspath(folder), file)
            debug("Reading " + filePath)
            data = read_json(filePath)
            simple = raw_to_simple(data)
            simple_group.append(simple)
    return simple_group


# Takes a list of chat logs in the "simple" format and extracts
# Only the burps detected by the burp bot
# FIXME: Version 1.2 multiburps not yet supported!!!
def simple_group_to_burp_data(simple_group, botname, prefix, exclude_list):
    burps = []
    for simple in simple_group:
        for message in simple:
            id = message[KEY_ID]
            text = message[KEY_TEXT]
            user = message[KEY_USER]
            if id not in exclude_list and user == botname and text.startswith(prefix):
                debug("Found rating: " + text)
                rating_text = text.replace(prefix, "")
                rating = float(rating_text) # FIXME! Multiburp, whitespace, ...
                burp = {
                    KEY_ID: id,
                    KEY_VOD: message[KEY_VOD],
                    KEY_TIME: message[KEY_TIME],
                    KEY_OFFSET: message[KEY_OFFSET],
                    KEY_RATING: rating
                }
                burps.append(burp)
    debug("Found {0} ratings.".format(len(burps)))
    return burps


#
# Analysis functions
#
def find_top_10_burps(burp_data):
    sorted_by_rating = sorted(burp_data, key=lambda x: x[KEY_RATING], reverse=True)
    top10 = sorted_by_rating[:10]
    debug(pformat(top10, indent=4))
    return top10


def read_exclude_list(filename):
    excludes = []
    with io.open(filename, 'r', encoding="utf-8") as exclude_file:
        lines = exclude_file.readlines()
        for line in lines:
            parts = line.split()
            if len(parts) > 0:
                excludes.append(parts[0])
                debug("Found excluded id: {0}".format((parts[0])))
    return excludes


def create_twitch_link(vod, offset):
    link_time = offset_to_twitch_time(offset)
    return "https://www.twitch.tv/videos/{vod}?t={link_time}".format(vod=vod, link_time=link_time)

def debug_burp_list(burp_data):
    if not debug_enabled:
        return
    for num, burp in enumerate(burp_data):
        # Link to 30 seconds before the rating
        link_seconds = max(0.0, (burp[KEY_OFFSET] - 30.0))
        link_time = offset_to_twitch_time(link_seconds)
        line = "#{rank} {rating:4.1f} https://www.twitch.tv/videos/{vod}?t={link_time} {time} {id}".format(
            rank = str(num+1).ljust(2),
            id = burp[KEY_ID],
            time = burp[KEY_TIME],
            rating= burp[KEY_RATING],
            vod= burp[KEY_VOD],
            link_time=link_time
        )
        debug(line)

def html_framework():
    title_text = u"Burpalyzer Results"
    html = ET.Element(u"html")
    head = ET.SubElement(html, u"head")
    title = ET.SubElement(head, u"title")
    title.text = title_text
    css = ET.SubElement(head, u"style")
    #css.set(u"type", u"text/css") # W3C tidy gives a warning for this?
    css.text = u"""
        table{
        border-collapse:collapse;
        border:1px solid black;
        }
        table td{
        border:1px solid black;
        padding: 10px
        }
    """
    body = ET.SubElement(html, u"body")
    h1 = ET.SubElement(body, u"h1")
    h1.text = title_text
    return (html, body)

def htlm_add_burp_list(parent, burp_data, description):
    h2 = ET.SubElement(parent, u"h2")
    h2.text = description
    table = ET.SubElement(parent, u"table")
    tr_head = ET.SubElement(table, u"tr")
    for header_text in (u"Rank", u"Rating", u"Time", u"Link", u"ID"):
        header = ET.SubElement(tr_head, u"th")
        header.text = header_text
    for num, burp in enumerate(burp_data):
        vod = burp[KEY_VOD]
        # Link to 30 seconds before the rating
        link_seconds = max(0.0, (burp[KEY_OFFSET] - 30.0))
        twitch_link_url = create_twitch_link(vod, link_seconds)
        tr = ET.SubElement(table, u"tr")
        rank = ET.SubElement(tr, u"td")
        rank.text = str(num+1)
        rating = ET.SubElement(tr, u"td")
        rating.text = "{0:4.1f}".format(burp[KEY_RATING])
        parsed_time = parse_chat_timestamp(burp[KEY_TIME])
        formatted_time = datetime_to_human_readable(parsed_time)
        time = ET.SubElement(tr, u"td")
        time.text = formatted_time
        link_td = ET.SubElement(tr, u"td")
        link_a = ET.SubElement(link_td, u"a")
        link_a.set(u"href", twitch_link_url)
        link_a.text = twitch_link_url
        id_element = ET.SubElement(tr, u"td")
        id_element.text = burp[KEY_ID]
    return table

# -------------------------------------------------------------------------------------------


if len(sys.argv) != 6:
    raise ValueError("Invalid number of arguments")
botname = sys.argv[1]
prefix = sys.argv[2]
indir = sys.argv[3]
excludefile = sys.argv[4]
outdir = sys.argv[5]

simple_group = read_folder_as_simple_group(indir)
exclude_list = read_exclude_list(excludefile)
burp_data = simple_group_to_burp_data(simple_group, botname, prefix, exclude_list)
top10 = find_top_10_burps(burp_data)
#debug_burp_list(top10)
(root, body) = html_framework()
top10_nodes = htlm_add_burp_list(body, top10, "Top 10 burps")
write_html(root, os.path.join(outdir, "results.html"))
